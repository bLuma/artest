<!doctype html>
<!--
Copyright 2021 The Immersive Web Community Group, 2022 Roman Diviš

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-->
<html>
  <head>
    <meta charset='utf-8'>
    <meta name="language" content="cs">
    <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
    <meta name='mobile-web-app-capable' content='yes'>
    <meta name='apple-mobile-web-app-capable' content='yes'>
    <link rel='icon' type='image/png' sizes='32x32' href='favicon-32x32.png'>
    <link rel='icon' type='image/png' sizes='96x96' href='favicon-96x96.png'>
    <link rel='stylesheet' href='css/common.css'>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.13.0/css/ol.css" type="text/css">
    <script src="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.13.0/build/ol.js"></script>
    <style>
      .map {
        height: 400px;
        width: 100%;
      }
    </style>

    <title>AR test</title>
    <style>
      #uiinner {
        background-color: black !important;
        color:white;
        padding: 3px;
        display: block;
      }

      #ui .pelement {
        display: inline-block;
        width: 4em;
        text-align: right;
      }
    </style>
  </head>
  <body>
    <header>
      <details open>
        <a href="./ar/index.html">ar.js</a>
          <!--<a class="back" href="./">Back</a>--> datetimehere

          <div id="map" class="map"></div>

      </details>
    </header>
    <div id="ui">
      <div id="uiinner">
        <div id="uitext">ui</div>
        <div id="uitext2">ui2</div>
        <div id="uitext3">ui3</div>
        <div id="uitext4">ui4</div>
        <div id="uitext5">ui5</div>
        <div id="uitext6"></div>
        <!-- <button id="findme">GPS</button> -->
      </div>
    </div>

    <script type="module">
      import {WebXRButton} from './js/util/webxr-button.js';
      import {Scene} from './js/render/scenes/scene.js';
      import {Renderer, createWebGLContext} from './js/render/core/renderer.js';
      import {Node} from './js/render/core/node.js';
      import {Gltf2Node} from './js/render/nodes/gltf2.js';
      import {DropShadowNode} from './js/render/nodes/drop-shadow.js';
      import {vec3,mat4} from './js/render/math/gl-matrix.js';
      import {Ray} from './js/render/math/ray.js';

      // XR globals.
      let xrButton = null;
      let xrRefSpace = null;
      let xrViewerSpace = null;
      let xrHitTestSource = null;

      // WebGL scene globals.
      let gl = null;
      let renderer = null;
      let scene = new Scene();
      scene.enableStats(false);

      // let arObject = new Node();
      // arObject.visible = false;
      // scene.addNode(arObject);

      // let flower = new Gltf2Node({url: 'media/gltf/pardubice_veselka/model01.glb'});
      // arObject.addNode(flower);

      let reticle = new Gltf2Node({url: 'media/gltf/reticle/reticle.gltf'});
      reticle.visible = false;
      scene.addNode(reticle);
      let reticleHitTestResult = null;

      // Having a really simple drop shadow underneath an object helps ground
      // it in the world without adding much complexity.
      // let shadow = new DropShadowNode();
      // vec3.set(shadow.scale, 0.15, 0.15, 0.15);
      // arObject.addNode(shadow);

      const MAX_FLOWERS = 30;
      let flowers = [];

      // Ensure the background is transparent for AR.
      scene.clear = false;

      function initXR() {
        xrButton = new WebXRButton({
          onRequestSession: onRequestSession,
          onEndSession: onEndSession,
          textEnterXRTitle: "START AR",
          textXRNotFoundTitle: "AR NOT FOUND",
          textExitXRTitle: "EXIT  AR",
        });
        document.querySelector('header').appendChild(xrButton.domElement);

        if (navigator.xr) {
          navigator.xr.isSessionSupported('immersive-ar')
                      .then((supported) => {
            xrButton.enabled = supported;
          });
        }
      }

      function onRequestSession() {
        const uiElement = document.querySelector('#ui');

        return navigator.xr.requestSession('immersive-ar', {
          requiredFeatures: ['local', 'hit-test', 'anchors'], 
          optionalFeatures: ['dom-overlay'],
          domOverlay: { root: uiElement } })
                           .then((session) => {
          xrButton.setSession(session);
          onSessionStarted(session);
        });
      }

      function onSessionStarted(session) {
        session.addEventListener('end', onSessionEnded);
        session.addEventListener('select', onSelect);

        if (!gl) {
          gl = createWebGLContext({
            xrCompatible: true
          });

          renderer = new Renderer(gl);

          scene.setRenderer(renderer);
        }

        session.updateRenderState({ baseLayer: new XRWebGLLayer(session, gl) });

        // In this sample we want to cast a ray straight out from the viewer's
        // position and render a reticle where it intersects with a real world
        // surface. To do this we first get the viewer space, then create a
        // hitTestSource that tracks it.
        session.requestReferenceSpace('viewer').then((refSpace) => {
          xrViewerSpace = refSpace;
          session.requestHitTestSource({ space: xrViewerSpace }).then((hitTestSource) => {
            xrHitTestSource = hitTestSource;
          });
        });

        session.requestReferenceSpace('local').then((refSpace) => {
          xrRefSpace = refSpace;

          session.requestAnimationFrame(onXRFrame);
        });
      }

      function onEndSession(session) {
        anchoredObjects.clear();
        xrHitTestSource.cancel();
        xrHitTestSource = null;
        session.end();
      }

      function onSessionEnded(event) {
        xrButton.setSession(null);
      }

      const MAX_ANCHORED_OBJECTS = 30;
      let anchoredObjects = [];
      function addAnchoredObjectsToScene(anchor, scale) {
        let flower = new Gltf2Node({url: 'media/gltf/pardubice_veselka/model01.glb'});
        flower.scale = [scale, scale, scale];
        scene.addNode(flower);
        anchoredObjects.push({
          anchoredObject: flower,
          anchor: anchor
        });

        // For performance reasons if we add too many objects start
        // removing the oldest ones to keep the scene complexity
        // from growing too much.
        if (anchoredObjects.length > MAX_ANCHORED_OBJECTS) {
          let objectToRemove = anchoredObjects.shift();
          scene.removeNode(objectToRemove.anchoredObject);
          objectToRemove.anchor.delete();
        }
      }

      let rayOrigin = vec3.create();
      let rayDirection = vec3.create();
      function onSelect(event) {
        if (reticle.visible) {
          // Create an anchor.
          reticleHitTestResult.createAnchor().then((anchor) => {
            addAnchoredObjectsToScene(anchor, 1);
          }, (error) => {
            console.error("Could not create anchor: " + error);
          });
        }
      }

      function valToStr(val) {
        const sval = (Math.round(+val * 100) / 100).toFixed(2);

        return `<span class="pelement">${sval}</span>`;
      }

      function fourValsToStr(a, b, c, d) {
        const sa = (Math.round(+a * 100) / 100).toFixed(2);
        const sb = (Math.round(+b * 100) / 100).toFixed(2);
        const sc = (Math.round(+c * 100) / 100).toFixed(2);
        const sd = (Math.round(+d * 100) / 100).toFixed(2);

        return `<span class="pelement">${sa}</span>/<span class="pelement">${sb}</span>/<span class="pelement">${sc}</span>/<span class="pelement">${sd}</span>`;
      }

      function pointToStr(point) {
        const {x, y, z, w} = point;
        return fourValsToStr(x, y, z, w);
      }

      function quatToStr(point) {
        const [a, b, c, d] = point;
        return fourValsToStr(a, b, c, d)
      }

      function convertGpsToXyzw(latitude, longitude) {
        const latr = latitude * Math.PI/180.0;
        const lonr = longitude * Math.PI/180.0;

        const r = 6378.1;
        const x = r * Math.cos(latr)*Math.cos(lonr);
        const y = r * Math.cos(latr)*Math.sin(lonr);
        const z = r * Math.sin(latr);

        return [x, y, z, 0];
      }

      function dist3d(p1, p2) {
        if (p1.x === undefined) {
          return Math.sqrt((p1[0]-p2[0])*(p1[0]-p2[0]) + (p1[1]-p2[1])*(p1[1]-p2[1]) + (p1[2]-p2[2])*(p1[2]-p2[2]));  
        }
        return Math.sqrt((p1.x-p2.x)*(p1.x-p2.x) + (p1.y-p2.y)*(p1.y-p2.y) + (p1.z-p2.z)*(p1.z-p2.z));
      }

      function distHarvesine(gps1, gps2) {
        const [lat1, lon1] = gps1;
        const [lat2, lon2] = gps2;

        const R = 6371e3; // metres
        const theta1 = lat1 * Math.PI/180; // φ, λ in radians
        const theta2 = lat2 * Math.PI/180;
        const deltaTheta = (lat2-lat1) * Math.PI/180;
        const deltaLambda = (lon2-lon1) * Math.PI/180;

        const a = Math.sin(deltaTheta/2) * Math.sin(deltaTheta/2) +
                  Math.cos(theta1) * Math.cos(theta2) *
                  Math.sin(deltaLambda/2) * Math.sin(deltaLambda/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

        const d = R * c; // in metres

        return d;
      }

      function gpsBearing(gps1, gps2) {
        const [lat1, lon1] = gps1;
        const [lat2, lon2] = gps2;
        const theta1 = lat1;
        const theta2 = lat2;
        const lambda1 = lon1;
        const lambda2 = lon2;

        const y = Math.sin(lambda2-lambda1) * Math.cos(theta2);
        const x = Math.cos(theta1)*Math.sin(theta2) -
                  Math.sin(theta1)*Math.cos(theta2)*Math.cos(lambda2-lambda1);
        const angl = Math.atan2(y, x);
        const brng = (angl*180/Math.PI + 360) % 360; // in degrees

        return brng;
      }

      let latitude = undefined;
      let longitude = undefined;
      let sensorquat = undefined;
      let devori = undefined;
      let yaw_ori = undefined;
      let phone_bearing = undefined;

      // kašna fei
      const interesting_lat = 50.033978;
      const interesting_lon = 15.767538;

      const models_at = [/* kašna fei */ [50.033978,15.767538,"kasna"], /* u domu */ [50.050206, 15.771499,"udomu"], /* veselka test */ [50.036244, 15.770473,"veselka"], [50.04861604866441, 15.77152305442406,"kruhak"]];
      //const models_at = [ [50.050206, 15.771499,"udomu"]];

      let addedOne = false;

      function updateUIInfo() {
        if (latitude !== undefined && longitude !== undefined && sensorquat !== undefined ) {
          const gps_dy = interesting_lat-latitude;
          const gps_dx = Math.cos(Math.PI/180.0*latitude) * (interesting_lon-longitude);
          const gps_angle = Math.atan2(gps_dy, gps_dx);
          const gps_angle_deg = gps_angle*180/Math.PI; // wrong???

          const gps_dist_harvesine = distHarvesine([latitude,longitude], [interesting_lat,interesting_lon]);
          const gps_bearing = gpsBearing([latitude,longitude], [interesting_lat,interesting_lon]); // 0 - sever, 360* podle hod. rucicek

          const [qx, qy, qz, qw] = sensorquat;

          const sinr_cosp = 2*(qw*qx + qy*qz);
          const cosr_cosp = 1 - 2*(qx*qx + qy*qy);
          const roll = Math.atan2(sinr_cosp, cosr_cosp);

          const sinp = 2*(qw*qy-qz*qx);
          const pitch = Math.abs(sinp) >= 1 ? Math.PI/2 * Math.sign(sinp) : Math.asin(sinp);

          const siny_cosp = 2*(qw*qz + qx*qy);
          const cosy_cosp = 1 - 2*(qy*qy + qz*qz);
          const yaw = Math.atan2(siny_cosp, cosy_cosp);
          yaw_ori = yaw*180/Math.PI;

          phone_bearing = 360 - (yaw_ori < 0 ? (180-Math.abs(yaw_ori)) + 180 : yaw_ori);

          document.querySelector('#uitext2').innerHTML = `gps: ${latitude} ° | ${longitude} °` +
            `<br>gpsxyz[km]: ${quatToStr(convertGpsToXyzw(latitude, longitude))}` +
            `<br>TARxyz[km]: ${quatToStr(convertGpsToXyzw(interesting_lat, interesting_lon))}` +
            `<br>TARdist[m]: ${valToStr(1000*dist3d(convertGpsToXyzw(latitude, longitude), convertGpsToXyzw(interesting_lat, interesting_lon)))} | ${valToStr(gps_dist_harvesine)}` +
            `<br>GpsAngle: ${valToStr(gps_angle)} | ${valToStr(gps_angle_deg)} | ${valToStr(gps_bearing)}` + 
            `<br>Bearing: ${valToStr(360 - (yaw_ori < 0 ? (180-Math.abs(yaw_ori)) + 180 : yaw_ori))}`;


          // roll 90 mobil vertikalne, 0 mobil lezi, 180 mobil kouka nahoru
          // pitch 0 - mobil rovne, -90 mobil na levem boku, 90 mobil na pravem boku 
          // yaw  sever-0, zapad-90, vychod--90 

          document.querySelector('#uitext3').innerHTML = "AOS: " + quatToStr(sensorquat);
          document.querySelector('#uitext4').innerHTML = "RPY(XYZ): " + quatToStr([roll*180/Math.PI, pitch*180/Math.PI, yaw*180/Math.PI, 0]);          
        }

        if (devori !== undefined) {
            document.querySelector('#uitext5').innerHTML = "DevOri: " + quatToStr([devori.alpha, devori.beta, devori.gamma, 0]);          
        }
      }

      // Called every time a XRSession requests that a new frame be drawn.
      function onXRFrame(t, frame) {
        let session = frame.session;
        let pose = frame.getViewerPose(xrRefSpace);
        let oriDeg = "";

        document.querySelector('#uitext').innerHTML = '' + 
            (pose && pose.transform ? "Pos: " + pointToStr(pose.transform.position) : "") + '<br>' +
            (pose && pose.transform ? "Ori: " + pointToStr(pose.transform.orientation) + "<br>" + oriDeg  : "");

        updateUIInfo();

        reticle.visible = false;

        // If we have a hit test source, get its results for the frame
        // and use the pose to display a reticle in the scene.
        if (xrHitTestSource && pose) {
          let hitTestResults = frame.getHitTestResults(xrHitTestSource);
          if (hitTestResults.length > 0) {
            let pose = hitTestResults[0].getPose(xrRefSpace);
            reticle.visible = true;
            reticle.matrix = pose.transform.matrix;
            reticleHitTestResult = hitTestResults[0];
          }
        }

        for (const {anchoredObject, anchor} of anchoredObjects) {
          // only update the object's position if it's still in the list
          // of frame.trackedAnchors
          if (!frame.trackedAnchors.has(anchor)) {
            continue;
          }
          const anchorPose = frame.getPose(anchor.anchorSpace, xrRefSpace);
          if (anchorPose === undefined ||anchorPose === null)
            continue;

          let t = mat4.create();
          mat4.identity(t);
          mat4.scale(t, t, [10,10,10]);//anchoredObject.scale);
          let r = mat4.create();
          mat4.multiply(r, anchorPose.transform.matrix, t);

          anchoredObject.matrix = anchorPose.transform.matrix;
          //anchoredObject.matrix = r;
        }

        if (!addedOne) {
          // +z k uzivateli, -z od uzivatele
          // +x doprava, -x doleva
          // +y nahoru, -y dolu
          //
          // - top-down view
          //  3                 0 q.
          //          | -z
          //     X----|----X
          //     | \An|An/ |
          // ---------+----------
          //  -x      |        +x  
          //          |
          //          | +z
          //   2                1
          // yaw  sever-0, zapad-90, vychod--90 
          //
          // const anchorPose = new XRRigidTransform({x: 0, y: -1, z: -5, w: 1}, {x: 0, y: 0, z: 0, w: 1});
          //const myGps = convertGpsToXyzw(latitude, longitude);
          //const targetGps = convertGpsToXyzw(interesting_lat, interesting_lon);
          //const distance = 1000*dist3d(convertGpsToXyzw(latitude, longitude), convertGpsToXyzw(interesting_lat, interesting_lon));


          for (const [tlat, tlon, tname] of models_at) {
            const gps_dist_harvesine = distHarvesine([latitude,longitude], [tlat,tlon]);
            let gps_bearing = gpsBearing([latitude,longitude], [tlat,tlon]) - phone_bearing; // 0 - sever, 360* podle hod. rucicek
            if (gps_bearing < 0)
              gps_bearing += 360;

            const gps_bearing_rad = gps_bearing * Math.PI / 180.0;
            //
            const gps_bearing_norm = gps_bearing >= 270 ? gps_bearing - 270 : (gps_bearing >= 180 ? gps_bearing - 180 : (gps_bearing >= 90 ? gps_bearing - 90 : gps_bearing));
            const gps_bearing_quadrant = gps_bearing >= 270 ? 3 : (gps_bearing >= 180 ? 2 : (gps_bearing >= 90 ? 1 : 0));
            const gps_bearing_norm_rad = gps_bearing_norm * Math.PI / 180.0; 

            const z_invert = (gps_bearing_quadrant === 1 || gps_bearing_quadrant === 2) ? -1 : 1;
            const x_invert = (gps_bearing_quadrant >= 2) ? -1 : 1;

            // sin bear = -z / dist
            // cos bear = +x / dist
            // -Z = sin bear * dist 
            // +x = cos  bear * dist
            let coord_z = -Math.cos(gps_bearing_norm_rad) * gps_dist_harvesine * z_invert;
            let coord_x = +Math.sin(gps_bearing_norm_rad) * gps_dist_harvesine * x_invert;

            if (gps_bearing_quadrant == 3) {
               coord_z = -Math.cos(Math.PI/2-gps_bearing_norm_rad) * gps_dist_harvesine;
               coord_x = -Math.sin(Math.PI/2-gps_bearing_norm_rad) * gps_dist_harvesine;
             }

            document.querySelector('#uitext6').innerHTML += `${valToStr(gps_dist_harvesine)} ${valToStr(coord_z)} ${valToStr(coord_x)}, `

            console.log(`${tname} ${gps_bearing} BearNorm:${gps_bearing_norm} BearNormRad:${gps_bearing_norm_rad} Quadrant:${gps_bearing_quadrant} zInv:${z_invert} xInv:${x_invert} Dist:${gps_dist_harvesine} X:${coord_x} Z:${coord_z}`);

            //const anchorPose = new XRRigidTransform({x: 0, y: -1.55, z: -5, w: 1}, {x: 0, y: 0, z: 0, w: 1});
            const anchorPose = new XRRigidTransform({x: coord_x, y: 0 /*-1.55*/, z: coord_z, w: 1}, {x: 0, y: 0, z: 0, w: 1});
            frame.createAnchor(anchorPose, xrRefSpace).then((anchor) => {
              addAnchoredObjectsToScene(anchor, 1000);
            }, (error) => {
              document.querySelector('#uitext6').innerHTML = ("Could not create anchor: " + error);
            });
          }
          addedOne = true;
        }

        scene.startFrame();
        session.requestAnimationFrame(onXRFrame);
        scene.drawXRFrame(frame, pose);
        scene.endFrame();
      }

      

      let requestedGps = false;
      let mapp = undefined;
      let map_view = undefined;
      function geoFindMe() {

        function success(position) {
          latitude  = position.coords.latitude;
          longitude = position.coords.longitude;

          requestedGps = false;

          if (mapp === undefined) {

            const features = [];
            const features2 = [];
            
            features2.push(new ol.Feature({
              geometry: new ol.geom.Point(ol.proj.fromLonLat([longitude, latitude])),
              name: 'ME',
            }));

            // const models_at = [/* kašna fei */ [50.033978,15.767538], /* u domu */ [50.050206, 15.771499], /* veselka test */ [50.036244, 15.770473],];
            for (const [tlat, tlon, tname] of models_at) {
              features.push(new ol.Feature({
                geometry: new ol.geom.Point(ol.proj.fromLonLat([tlon,tlat])),
                name: tname,
              }));
            }

            mapp = new ol.Map({
              target: 'map',
              layers: [
                new ol.layer.Tile({
                  source: new ol.source.OSM(),
                }),
                new ol.layer.Vector({
                  source: new ol.source.Vector({
                    features: features2
                  }),
                  style: new ol.style.Style({
                    image: new ol.style.Icon({
                      //anchor: [0.5, 46],
                      //anchorXUnits: 'fraction',
                      //anchorYUnits: 'pixels',
                      src: './media/marker2.png'
                    })
                  })
                }),                
                new ol.layer.Vector({
                  source: new ol.source.Vector({
                    features: features
                  }),
                  style: new ol.style.Style({
                    image: new ol.style.Icon({
                      src: './media/marker.png'
                    })
                  })
                })
              ],
              view: (map_view = new ol.View({
                center: ol.proj.fromLonLat([longitude, latitude]),
                zoom: 18
              }))
            });


          } else {
            // console.log(mapp.view)
            map_view.setRotation((360-phone_bearing)*Math.PI/180.0);
          }
        }

        function error() {
          document.querySelector('#uitext2').textContent = 'Unable to retrieve your location';
          requestedGps = false;
        }

        if(!navigator.geolocation) {
          document.querySelector('#uitext2').textContent = 'GPS is not supported by your browser';
        } else {
          requestedGps = true;
          navigator.geolocation.getCurrentPosition(success, error);
        }

      }

      //document.querySelector('#findme').addEventListener('click', geoFindMe);

      window.addEventListener('deviceorientation', (e) => {
        devori = e;
      });


      const sensor = new AbsoluteOrientationSensor();
      Promise.all([navigator.permissions.query({ name: "geolocation" }), 
                  navigator.permissions.query({ name: "accelerometer" }),
                  navigator.permissions.query({ name: "magnetometer" }),
                  navigator.permissions.query({ name: "gyroscope" })])
            .then(results => {
              if (results.every(result => result.state === "granted")) {

                sensor.addEventListener('reading', () => {
                  sensorquat = sensor.quaternion;
                  updateUIInfo();

                  if (!requestedGps) {
                    geoFindMe();
                  }
                });
                sensor.addEventListener('error', error => {
                  if (event.error.name == 'NotReadableError') {
                    document.querySelector('#uitext3').textContent ="AbsoluteOrientationSensor is not available.";
                  }
                });

                sensor.start();
                geoFindMe();

              } else {
                document.querySelector('#uitext3').textContent = "No permissions.";
              }
        });

      // Start the XR application.
      initXR();
    </script>
  </body>
</html>